import { COOKIE_NAME } from "@shared/const";
import { getSessionCookieOptions } from "./_core/cookies";
import { systemRouter } from "./_core/systemRouter";
import { publicProcedure, protectedProcedure, router } from "./_core/trpc";
import { z } from "zod";
import { TRPCError } from "@trpc/server";
import * as db from "./db";
import { executeMultiAgentAnalysis } from "./agents/multiAgentSystem";
import { parseGitHubUrl } from "./agents/tools";

/**
 * Generate markdown report from analysis results
 */
function generateMarkdownReport(
  analysis: db.AnalysisHistory,
  results: db.AnalysisResults
): string {
  const tags = results.suggestedTags
    ? JSON.parse(results.suggestedTags)
    : [];
  const categories = results.suggestedCategories
    ? JSON.parse(results.suggestedCategories)
    : [];
  const missingSections = results.missingSections
    ? JSON.parse(results.missingSections)
    : [];
  const visualEnhancements = results.visualEnhancements
    ? JSON.parse(results.visualEnhancements)
    : [];

  return `# Repository Analysis Report

## Repository Information
- **Name**: ${analysis.repositoryName}
- **Owner**: ${analysis.repositoryOwner}
- **URL**: ${analysis.repositoryUrl}
- **Analysis Date**: ${new Date(analysis.createdAt).toLocaleDateString()}

## Overall Score
**${results.overallScore}/100**

## Repository Analysis
${results.readmeAnalysis || "No analysis available"}

## Title Suggestion
${results.titleSuggestion || "No suggestion"}

## Summary Improvement
${results.summaryImprovement || "No suggestion"}

## Suggested Tags
${tags.map((tag: string) => `- ${tag}`).join("\n") || "No tags suggested"}

## Suggested Categories
${categories.map((cat: string) => `- ${cat}`).join("\n") || "No categories suggested"}

## Missing Sections
${missingSections.map((section: string) => `- ${section}`).join("\n") || "No missing sections identified"}

## Visual Enhancements
${visualEnhancements.map((enhancement: string) => `- ${enhancement}`).join("\n") || "No enhancements suggested"}

---
*Generated by AAIDC Multi-Agent Publication Assistant*`;
}

/**
 * Execute analysis asynchronously in the background
 */
async function executeAnalysisAsync(analysisId: number, repositoryUrl: string) {
  try {
    await db.updateAnalysisStatus(analysisId, "processing");

    const result = await executeMultiAgentAnalysis(repositoryUrl, (agent, status) => {
      console.log(`[${agent}] ${status}`);
    });

    // Save results to database
    await db.saveAnalysisResults(analysisId, {
      titleSuggestion: result.titleSuggestion,
      summaryImprovement: result.summaryImprovement,
      suggestedTags: JSON.stringify(result.suggestedTags),
      suggestedCategories: JSON.stringify(result.suggestedCategories),
      missingSections: JSON.stringify(result.missingSections),
      visualEnhancements: JSON.stringify(result.visualEnhancements),
      readmeAnalysis: result.repoAnalysis,
      overallScore: result.overallScore,
      rawAnalysisData: JSON.stringify(result),
    });

    await db.updateAnalysisStatus(analysisId, "completed");
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    await db.updateAnalysisStatus(analysisId, "failed", errorMsg);
    console.error(`Analysis failed for ID ${analysisId}:`, error);
  }
}

export const appRouter = router({
  system: systemRouter,
  auth: router({
    me: publicProcedure.query((opts) => opts.ctx.user),
    logout: publicProcedure.mutation(({ ctx }) => {
      const cookieOptions = getSessionCookieOptions(ctx.req);
      ctx.res.clearCookie(COOKIE_NAME, { ...cookieOptions, maxAge: -1 });
      return {
        success: true,
      } as const;
    }),
  }),

  analysis: router({
    initiate: protectedProcedure
      .input(z.object({ repositoryUrl: z.string().url() }))
      .mutation(async ({ ctx, input }) => {
        const parsed = parseGitHubUrl(input.repositoryUrl);
        if (!parsed) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "Invalid GitHub repository URL",
          });
        }

        const result = await db.createAnalysis(
          ctx.user.id,
          input.repositoryUrl,
          parsed.repo,
          parsed.owner
        );

        const analysisId = (result as any).insertId;

        // Start async analysis in background
        executeAnalysisAsync(analysisId, input.repositoryUrl).catch((err) =>
          console.error("Background analysis error:", err)
        );

        return { analysisId };
      }),

    getResults: protectedProcedure
      .input(z.object({ analysisId: z.number() }))
      .query(async ({ ctx, input }) => {
        const analysis = await db.getAnalysisById(input.analysisId);
        if (!analysis || analysis.userId !== ctx.user.id) {
          throw new TRPCError({
            code: "NOT_FOUND",
            message: "Analysis not found",
          });
        }

        const results = await db.getAnalysisResults(input.analysisId);
        return { analysis, results };
      }),

    history: protectedProcedure.query(async ({ ctx }) => {
      return await db.getUserAnalysisHistory(ctx.user.id);
    }),

    delete: protectedProcedure
      .input(z.object({ analysisId: z.number() }))
      .mutation(async ({ ctx, input }) => {
        const analysis = await db.getAnalysisById(input.analysisId);
        if (!analysis || analysis.userId !== ctx.user.id) {
          throw new TRPCError({
            code: "NOT_FOUND",
            message: "Analysis not found",
          });
        }

        await db.deleteAnalysis(input.analysisId);
        return { success: true };
      }),

    export: protectedProcedure
      .input(z.object({ analysisId: z.number() }))
      .query(async ({ ctx, input }) => {
        const analysis = await db.getAnalysisById(input.analysisId);
        if (!analysis || analysis.userId !== ctx.user.id) {
          throw new TRPCError({
            code: "NOT_FOUND",
            message: "Analysis not found",
          });
        }

        const results = await db.getAnalysisResults(input.analysisId);
        if (!results) {
          throw new TRPCError({
            code: "NOT_FOUND",
            message: "Results not found",
          });
        }

        const markdown = generateMarkdownReport(analysis, results);
        return { markdown };
      }),
  }),
});

export type AppRouter = typeof appRouter;
